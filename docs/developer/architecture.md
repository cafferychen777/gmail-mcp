# æŠ€æœ¯æ¶æ„æ–‡æ¡£

> **Gmail MCP Bridge ç³»ç»Ÿè®¾è®¡ä¸å®ç°ç»†èŠ‚**

## ğŸ¯ æ¶æ„è®¾è®¡ç†å¿µ

Gmail MCP Bridge åŸºäºä»¥ä¸‹æ ¸å¿ƒåŸåˆ™è®¾è®¡ï¼š

1. **æ•°æ®ç»“æ„ä¼˜å…ˆ** - å¥½çš„æ•°æ®ç»“æ„è®©ä»£ç è‡ªç„¶ç®€æ´
2. **æ¶ˆé™¤ç‰¹æ®Šæƒ…å†µ** - ç»Ÿä¸€çš„å¤„ç†æœºåˆ¶ï¼Œå‡å°‘æ¡ä»¶åˆ†æ”¯
3. **å®ç”¨ä¸»ä¹‰** - è§£å†³çœŸå®ç”¨æˆ·é—®é¢˜ï¼Œä¸è¿½æ±‚ç†è®ºå®Œç¾
4. **å‘åå…¼å®¹** - ä»»ä½•æ”¹åŠ¨éƒ½ä¸ç ´åç°æœ‰ç”¨æˆ·çš„ä½¿ç”¨

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### ç³»ç»Ÿå±‚æ¬¡ç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ç”¨æˆ·å±‚                                â”‚
â”‚  Claude Desktop    Chrome Browser    CLIå·¥å…·    Webç•Œé¢     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      åè®®å±‚                                  â”‚
â”‚         MCPåè®®        HTTP API        Native Messaging     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æœåŠ¡å±‚                                  â”‚
â”‚    MCPæœåŠ¡å™¨      BridgeæœåŠ¡å™¨      çŠ¶æ€ç®¡ç†      é”™è¯¯å¤„ç†   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ‰©å±•å±‚                                  â”‚
â”‚  Chrome Extension    Content Scripts    Background Service  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      åº”ç”¨å±‚                                  â”‚
â”‚              Gmail Web Interface                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®æµç¤ºä¾‹

```mermaid
sequenceDiagram
    participant C as Claude Desktop
    participant M as MCP Server
    participant B as Bridge Server
    participant E as Chrome Extension
    participant G as Gmail

    C->>M: è°ƒç”¨get_emailså·¥å…·
    M->>B: HTTPè¯·æ±‚ /api/emails
    B->>E: è½®è¯¢æ¶ˆæ¯é˜Ÿåˆ—
    E->>G: DOMæ“ä½œè·å–é‚®ä»¶
    G->>E: è¿”å›é‚®ä»¶æ•°æ®
    E->>B: æ¨é€é‚®ä»¶æ•°æ®
    B->>M: è¿”å›HTTPå“åº”
    M->>C: è¿”å›é‚®ä»¶åˆ—è¡¨
```

---

## ğŸ§  æ ¸å¿ƒç»„ä»¶è¯¦è§£

### 1. MCPæœåŠ¡å™¨ (MCP Server)

**æ–‡ä»¶ä½ç½®**: `mcp-server/index.js`

**èŒè´£**ï¼š
- å®ç°MCPåè®®è§„èŒƒ
- æä¾›å·¥å…·æ¥å£ç»™Claude Desktop
- ç®¡ç†ä¸BridgeæœåŠ¡å™¨çš„é€šä¿¡

**æ ¸å¿ƒç±»è®¾è®¡**ï¼š

```javascript
class MCPServer {
  constructor() {
    this.tools = new Map();
    this.bridge = new BridgeClient('http://localhost:3456');
    this.config = new ConfigManager();
  }
  
  // MCPå·¥å…·å®šä¹‰
  initializeTools() {
    this.tools.set('list_emails', {
      name: 'list_emails',
      description: 'List emails from Gmail inbox',
      inputSchema: {
        type: 'object',
        properties: {
          limit: { type: 'number', default: 10 },
          unread_only: { type: 'boolean', default: false }
        }
      }
    });
    // ... æ›´å¤šå·¥å…·
  }
  
  // å·¥å…·è°ƒç”¨å¤„ç†
  async callTool(name, args) {
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(`Unknown tool: ${name}`);
    }
    
    return await this.bridge.request(`/api/${name}`, args);
  }
}
```

### 2. BridgeæœåŠ¡å™¨ (Bridge Server)

**æ–‡ä»¶ä½ç½®**: `mcp-server/bridge-server.js`

**èŒè´£**ï¼š
- HTTP APIæœåŠ¡å™¨
- MCPæœåŠ¡å™¨å’ŒChromeæ‰©å±•çš„é€šä¿¡æ¡¥æ¢
- è¯·æ±‚é˜Ÿåˆ—ç®¡ç†å’Œå“åº”è·¯ç”±

**æ ¸å¿ƒæ¶æ„**ï¼š

```javascript
class BridgeServer {
  constructor(port = 3456) {
    this.port = port;
    this.pendingRequests = new Map(); // requestId -> Promise
    this.chromeClients = new Set();   // è¿æ¥çš„Chromeæ‰©å±•
    this.messageQueue = [];           // æ¶ˆæ¯é˜Ÿåˆ—
    this.app = express();
  }
  
  // APIè·¯ç”±å®šä¹‰
  setupRoutes() {
    this.app.get('/health', this.healthCheck);
    this.app.post('/api/:action', this.handleApiRequest);
    this.app.get('/poll', this.handlePoll);  // Chromeæ‰©å±•è½®è¯¢
    this.app.post('/response', this.handleResponse);
  }
  
  // æ ¸å¿ƒï¼šè¯·æ±‚-å“åº”æœºåˆ¶
  async handleApiRequest(req, res) {
    const { action } = req.params;
    const requestId = this.generateRequestId();
    
    // å°†è¯·æ±‚å‘é€åˆ°Chromeæ‰©å±•
    const message = {
      id: requestId,
      action: action,
      data: req.body,
      timestamp: Date.now()
    };
    
    this.messageQueue.push(message);
    
    // ç­‰å¾…Chromeæ‰©å±•å“åº”
    try {
      const result = await this.waitForResponse(requestId, 10000);
      res.json({ success: true, data: result });
    } catch (error) {
      res.status(500).json({ success: false, error: error.message });
    }
  }
}
```

### 3. Chromeæ‰©å±• (Chrome Extension)

**æ–‡ä»¶ä½ç½®**: `extension/` ç›®å½•

**æ¶æ„ç»„æˆ**ï¼š

- **manifest.json** - æ‰©å±•é…ç½®å’Œæƒé™å£°æ˜
- **background.js** - æœåŠ¡å·¥ä½œè€…ï¼Œå¤„ç†Bridgeé€šä¿¡
- **content.js** - å†…å®¹è„šæœ¬ï¼Œæ“ä½œGmail DOM
- **popup.js** - æ‰©å±•å¼¹çª—ï¼Œç”¨æˆ·ç•Œé¢

**Background Scriptè®¾è®¡**ï¼š

```javascript
class ExtensionBackground {
  constructor() {
    this.bridgeUrl = 'http://localhost:3456';
    this.pollInterval = 1000;
    this.isConnected = false;
  }
  
  // è½®è¯¢BridgeæœåŠ¡å™¨è·å–æ¶ˆæ¯
  async pollMessages() {
    try {
      const response = await fetch(`${this.bridgeUrl}/poll`);
      const messages = await response.json();
      
      for (const message of messages) {
        await this.processMessage(message);
      }
    } catch (error) {
      console.error('Poll failed:', error);
      this.isConnected = false;
    }
  }
  
  // å¤„ç†æ¥è‡ªBridgeçš„æ¶ˆæ¯
  async processMessage(message) {
    const { id, action, data } = message;
    
    try {
      // å‘Gmailæ ‡ç­¾é¡µå‘é€æ¶ˆæ¯
      const result = await this.sendToContentScript(action, data);
      
      // å°†ç»“æœå‘é€å›Bridge
      await this.sendResponse(id, result);
    } catch (error) {
      await this.sendError(id, error);
    }
  }
}
```

**Content Scriptè®¾è®¡**ï¼š

```javascript
class GmailController {
  constructor() {
    this.selectors = {
      emailList: 'tr.zA',
      emailSubject: 'span[data-thread-id] span[id*=":"]',
      composeButton: '.T-I.T-I-KE.L3',
      // ... æ›´å¤šé€‰æ‹©å™¨
    };
  }
  
  // è·å–é‚®ä»¶åˆ—è¡¨
  getEmails(options = {}) {
    const { limit = 10, unread_only = false } = options;
    const rows = document.querySelectorAll(this.selectors.emailList);
    
    const emails = Array.from(rows)
      .slice(0, limit)
      .filter(row => !unread_only || this.isUnread(row))
      .map(row => this.extractEmailData(row));
    
    return emails;
  }
  
  // å‘é€é‚®ä»¶
  async sendEmail({ to, subject, body }) {
    // ç‚¹å‡»æ’°å†™æŒ‰é’®
    const composeBtn = document.querySelector(this.selectors.composeButton);
    composeBtn.click();
    
    // ç­‰å¾…æ’°å†™ç•Œé¢åŠ è½½
    await this.waitForComposer();
    
    // å¡«å†™è¡¨å•
    this.fillComposer({ to, subject, body });
    
    // å‘é€é‚®ä»¶
    await this.clickSend();
  }
}
```

---

## ğŸ”„ æ•°æ®çŠ¶æ€ç®¡ç†

### ç³»ç»ŸçŠ¶æ€æ¨¡å‹

```javascript
class SystemState {
  constructor() {
    this.components = {
      mcpServer: {
        status: 'unknown',    // unknown, starting, running, error
        lastCheck: null,
        pid: null,
        version: null
      },
      bridgeServer: {
        status: 'unknown',
        port: 3456,
        lastHeartbeat: null,
        connectedClients: 0
      },
      chromeExtension: {
        status: 'unknown',
        id: null,
        version: null,
        isConnected: false
      },
      gmail: {
        tabs: [],            // [{ tabId, url, account, isActive }]
        currentAccount: null,
        isLoggedIn: false
      }
    };
    
    this.metrics = {
      responseTime: new RollingAverage(100),
      errorRate: new RollingAverage(50),
      successRate: new RollingAverage(50),
      uptime: Date.now()
    };
    
    this.errors = new Map();  // errorId -> ErrorInfo
  }
}
```

### é…ç½®ç®¡ç†æ¶æ„

```javascript
class ConfigurationManager {
  constructor() {
    this.configs = new Map();
    this.watchers = new Map();
    this.validators = new Map();
  }
  
  // ç»Ÿä¸€é…ç½®æ›´æ–°æœºåˆ¶
  async updateConfig(path, updates) {
    const backup = await this.createBackup(path);
    
    try {
      const current = await this.loadConfig(path);
      const merged = this.mergeConfig(current, updates);
      
      await this.validateConfig(path, merged);
      await this.saveConfig(path, merged);
      
      this.notifyWatchers(path, merged);
      
      return merged;
    } catch (error) {
      await this.restoreBackup(path, backup);
      throw error;
    }
  }
}
```

---

## ğŸ›¡ï¸ é”™è¯¯å¤„ç†æœºåˆ¶

### ç»Ÿä¸€é”™è¯¯å¤„ç†

```javascript
class ErrorManager {
  constructor() {
    this.errorCodes = new Map();
    this.handlers = new Map();
    this.userMessages = new Map();
    
    this.initializeErrorMappings();
  }
  
  // é”™è¯¯åˆ†ç±»å’Œå¤„ç†
  async handleError(error, context = {}) {
    const errorInfo = this.classifyError(error, context);
    const handler = this.getHandler(errorInfo.code);
    
    if (handler.autoFix && await handler.canAutoFix(errorInfo)) {
      try {
        await handler.autoFix(errorInfo);
        return { resolved: true, action: 'auto_fixed' };
      } catch (fixError) {
        // è‡ªåŠ¨ä¿®å¤å¤±è´¥ï¼Œé™çº§åˆ°æ‰‹åŠ¨å¤„ç†
        return this.createManualResolution(errorInfo);
      }
    }
    
    return this.createManualResolution(errorInfo);
  }
  
  initializeErrorMappings() {
    // Bridgeè¿æ¥é”™è¯¯
    this.errorCodes.set('BRIDGE_CONNECTION_FAILED', {
      severity: 'high',
      category: 'network',
      autoFixable: true
    });
    
    this.handlers.set('BRIDGE_CONNECTION_FAILED', {
      canAutoFix: async () => await this.checkBridgeServer(),
      autoFix: async () => await this.restartBridge(),
      manualSteps: [
        'æ£€æŸ¥BridgeæœåŠ¡å™¨æ˜¯å¦è¿è¡Œ',
        'è¿è¡Œ npm run bridge é‡å¯æœåŠ¡',
        'æ£€æŸ¥ç«¯å£3456æ˜¯å¦è¢«å ç”¨'
      ]
    });
  }
}
```

### è‡ªåŠ¨æ¢å¤æœºåˆ¶

```javascript
class AutoRecovery {
  constructor() {
    this.strategies = new Map();
    this.monitors = new Set();
    this.recoveryHistory = [];
  }
  
  // ç»„ä»¶æ•…éšœè‡ªåŠ¨æ¢å¤
  async recoverComponent(component, error) {
    const strategy = this.strategies.get(component);
    if (!strategy) {
      return { success: false, reason: 'no_strategy' };
    }
    
    const steps = strategy.getRecoverySteps(error);
    
    for (const step of steps) {
      try {
        await step.execute();
        
        if (await step.verify()) {
          return { success: true, step: step.name };
        }
      } catch (stepError) {
        console.error(`Recovery step ${step.name} failed:`, stepError);
      }
    }
    
    return { success: false, reason: 'all_steps_failed' };
  }
}
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### ç¼“å­˜ç³»ç»Ÿ

```javascript
class IntelligentCache {
  constructor() {
    this.cache = new Map();
    this.stats = {
      hits: 0,
      misses: 0,
      evictions: 0
    };
    this.ttlTimers = new Map();
  }
  
  // æ™ºèƒ½ç¼“å­˜ç­–ç•¥
  async get(key, fetcher, options = {}) {
    if (this.has(key) && !this.isExpired(key)) {
      this.stats.hits++;
      return this.cache.get(key).value;
    }
    
    this.stats.misses++;
    const value = await fetcher();
    
    this.set(key, value, {
      ttl: this.calculateTTL(key, options),
      priority: this.calculatePriority(key, options)
    });
    
    return value;
  }
  
  calculateTTL(key, options) {
    // åŸºäºæ•°æ®ç±»å‹å’Œè®¿é—®æ¨¡å¼çš„åŠ¨æ€TTL
    const patterns = {
      'gmail-emails': 30000,     // 30ç§’
      'system-status': 5000,     // 5ç§’  
      'user-config': 300000,     // 5åˆ†é’Ÿ
      'error-info': 60000        // 1åˆ†é’Ÿ
    };
    
    const keyType = this.getKeyType(key);
    return options.ttl || patterns[keyType] || 60000;
  }
}
```

### è¿æ¥æ± ç®¡ç†

```javascript
class ConnectionPool {
  constructor(maxConnections = 5) {
    this.maxConnections = maxConnections;
    this.activeConnections = new Map();
    this.idleConnections = new Set();
    this.waitingQueue = [];
  }
  
  // è¿æ¥å¤ç”¨
  async getConnection(target) {
    // å¤ç”¨ç©ºé—²è¿æ¥
    for (const conn of this.idleConnections) {
      if (conn.target === target && conn.isHealthy()) {
        this.idleConnections.delete(conn);
        this.activeConnections.set(conn.id, conn);
        return conn;
      }
    }
    
    // åˆ›å»ºæ–°è¿æ¥
    if (this.activeConnections.size < this.maxConnections) {
      const conn = await this.createConnection(target);
      this.activeConnections.set(conn.id, conn);
      return conn;
    }
    
    // ç­‰å¾…è¿æ¥é‡Šæ”¾
    return new Promise((resolve, reject) => {
      this.waitingQueue.push({ target, resolve, reject });
    });
  }
}
```

---

## ğŸ” å®‰å…¨æ¶æ„

### æ•°æ®éšç§ä¿æŠ¤

```javascript
class PrivacyController {
  constructor() {
    this.sensitiveFields = new Set([
      'email_content', 'password', 'auth_token'
    ]);
    this.processors = new Map();
  }
  
  // æ•°æ®è„±æ•å¤„ç†
  sanitizeData(data, context = {}) {
    if (typeof data !== 'object') {
      return data;
    }
    
    const sanitized = {};
    
    for (const [key, value] of Object.entries(data)) {
      if (this.sensitiveFields.has(key)) {
        sanitized[key] = this.maskSensitiveValue(value);
      } else if (typeof value === 'object') {
        sanitized[key] = this.sanitizeData(value, context);
      } else {
        sanitized[key] = value;
      }
    }
    
    return sanitized;
  }
  
  // æœ¬åœ°æ•°æ®å¤„ç†åŸåˆ™
  processEmailData(emailData) {
    return {
      // åªä¿ç•™å¿…è¦çš„å…ƒæ•°æ®
      id: emailData.id,
      subject: emailData.subject,
      from: emailData.from,
      timestamp: emailData.timestamp,
      // ä¸å­˜å‚¨é‚®ä»¶æ­£æ–‡
      hasAttachments: emailData.attachments?.length > 0,
      isRead: emailData.isRead
    };
  }
}
```

### æƒé™æ§åˆ¶

```javascript
class PermissionManager {
  constructor() {
    this.permissions = new Map();
    this.policies = new Map();
  }
  
  // æœ€å°æƒé™éªŒè¯
  async checkPermission(action, resource, context) {
    const required = this.getRequiredPermissions(action, resource);
    const granted = await this.getGrantedPermissions(context);
    
    return required.every(perm => granted.includes(perm));
  }
  
  // Chromeæ‰©å±•æƒé™ç®¡ç†
  async requestChromePermissions(permissions) {
    return new Promise((resolve) => {
      chrome.permissions.request({
        permissions: permissions
      }, (granted) => {
        resolve(granted);
      });
    });
  }
}
```

---

## ğŸ“Š ç›‘æ§å’ŒæŒ‡æ ‡

### æ€§èƒ½ç›‘æ§

```javascript
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.thresholds = new Map();
    this.alerts = new Set();
  }
  
  // æ€§èƒ½æŒ‡æ ‡æ”¶é›†
  recordMetric(name, value, labels = {}) {
    const key = this.buildMetricKey(name, labels);
    
    if (!this.metrics.has(key)) {
      this.metrics.set(key, new MetricSeries());
    }
    
    const series = this.metrics.get(key);
    series.add(value, Date.now());
    
    // æ£€æŸ¥é˜ˆå€¼å‘Šè­¦
    this.checkThresholds(name, value, labels);
  }
  
  // ç³»ç»Ÿå¥åº·æ£€æŸ¥
  async healthCheck() {
    const components = ['mcp', 'bridge', 'extension', 'gmail'];
    const results = {};
    
    for (const component of components) {
      try {
        results[component] = await this.checkComponent(component);
      } catch (error) {
        results[component] = {
          status: 'error',
          error: error.message
        };
      }
    }
    
    return {
      overall: this.calculateOverallHealth(results),
      components: results,
      timestamp: Date.now()
    };
  }
}
```

---

## ğŸ”„ å‡çº§å’Œå…¼å®¹æ€§

### å‘å‰å…¼å®¹è®¾è®¡

```javascript
class VersionManager {
  constructor() {
    this.supportedVersions = ['1.0.0', '1.1.0', '2.0.0'];
    this.migrators = new Map();
    this.validators = new Map();
  }
  
  // é…ç½®è¿ç§»
  async migrateConfig(config, targetVersion) {
    const currentVersion = this.detectVersion(config);
    
    if (this.isCompatible(currentVersion, targetVersion)) {
      return config;
    }
    
    const migrationPath = this.findMigrationPath(currentVersion, targetVersion);
    
    let migratedConfig = config;
    for (const step of migrationPath) {
      migratedConfig = await this.executeMigration(step, migratedConfig);
    }
    
    return migratedConfig;
  }
  
  // å‘åå…¼å®¹æ£€æŸ¥
  isBackwardCompatible(newVersion, oldVersion) {
    // ä¸»ç‰ˆæœ¬å·ç›¸åŒæ—¶ä¿è¯å‘åå…¼å®¹
    const [newMajor] = newVersion.split('.');
    const [oldMajor] = oldVersion.split('.');
    
    return newMajor === oldMajor;
  }
}
```

---

## ğŸ› ï¸ å¼€å‘å·¥å…·å’Œè°ƒè¯•

### å¼€å‘ç¯å¢ƒè®¾ç½®

```bash
# å¼€å‘ç¯å¢ƒå¿«é€Ÿå¯åŠ¨
npm run dev:setup    # å®‰è£…ä¾èµ–å¹¶é…ç½®å¼€å‘ç¯å¢ƒ
npm run dev:start    # å¯åŠ¨æ‰€æœ‰æœåŠ¡ï¼ˆçƒ­é‡è½½ï¼‰
npm run dev:test     # è¿è¡Œæµ‹è¯•å¥—ä»¶
npm run dev:debug    # å¯åŠ¨è°ƒè¯•æ¨¡å¼
```

### è°ƒè¯•å·¥å…·

```javascript
class DebugHelper {
  constructor() {
    this.logLevel = process.env.DEBUG_LEVEL || 'info';
    this.debugModules = new Set(process.env.DEBUG?.split(',') || []);
  }
  
  // ç»“æ„åŒ–æ—¥å¿—
  log(level, module, message, data = {}) {
    if (!this.shouldLog(level, module)) {
      return;
    }
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      module,
      message,
      data,
      pid: process.pid
    };
    
    console.log(JSON.stringify(logEntry));
  }
  
  // æ€§èƒ½åˆ†æ
  profile(name, fn) {
    const start = performance.now();
    
    return Promise.resolve(fn()).finally(() => {
      const duration = performance.now() - start;
      this.log('debug', 'profiler', `${name} took ${duration.toFixed(2)}ms`);
    });
  }
}
```

---

## ğŸ“‹ éƒ¨ç½²æ¶æ„

### ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

```yaml
# docker-compose.yml
version: '3.8'
services:
  mcp-server:
    build: ./mcp-server
    ports:
      - "3455:3455"
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=info
    restart: unless-stopped
    
  bridge-server:
    build: ./mcp-server
    command: npm run bridge
    ports:
      - "3456:3456"
    environment:
      - NODE_ENV=production
      - CORS_ORIGIN=chrome-extension://*
    restart: unless-stopped
    depends_on:
      - mcp-server
```

### ç›‘æ§å’Œå‘Šè­¦

```javascript
class ProductionMonitoring {
  constructor() {
    this.alertChannels = new Map();
    this.healthChecks = new Map();
  }
  
  // ç³»ç»Ÿç›‘æ§
  startMonitoring() {
    // æ¯30ç§’æ£€æŸ¥ç³»ç»Ÿå¥åº·
    setInterval(async () => {
      const health = await this.checkSystemHealth();
      if (!health.healthy) {
        await this.triggerAlert('system_unhealthy', health);
      }
    }, 30000);
    
    // æ¯5åˆ†é’Ÿæ£€æŸ¥æ€§èƒ½æŒ‡æ ‡
    setInterval(async () => {
      const metrics = await this.collectMetrics();
      if (this.detectAnomalies(metrics)) {
        await this.triggerAlert('performance_anomaly', metrics);
      }
    }, 300000);
  }
}
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### ä»£ç ç»„ç»‡åŸåˆ™

1. **å•ä¸€èŒè´£** - æ¯ä¸ªæ¨¡å—åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½
2. **ä¾èµ–æ³¨å…¥** - é¿å…ç¡¬ç¼–ç ä¾èµ–
3. **é”™è¯¯è¾¹ç•Œ** - é”™è¯¯ä¸åº”è¯¥è·¨æ¨¡å—ä¼ æ’­
4. **é…ç½®å¤–éƒ¨åŒ–** - æ‰€æœ‰é…ç½®éƒ½å¯ä»¥å¤–éƒ¨ä¿®æ”¹

### æ€§èƒ½ä¼˜åŒ–æŒ‡å—

1. **ç¼“å­˜ç­–ç•¥** - æ ¹æ®æ•°æ®ç‰¹æ€§é€‰æ‹©åˆé€‚çš„ç¼“å­˜TTL
2. **è¿æ¥å¤ç”¨** - é¿å…é¢‘ç¹åˆ›å»ºHTTPè¿æ¥
3. **æ‰¹é‡æ“ä½œ** - åˆå¹¶å¤šä¸ªå°è¯·æ±‚ä¸ºæ‰¹é‡è¯·æ±‚
4. **å¼‚æ­¥å¤„ç†** - é¿å…é˜»å¡ä¸»çº¿ç¨‹

### å®‰å…¨æœ€ä½³å®è·µ

1. **æœ€å°æƒé™** - åªç”³è¯·å¿…è¦çš„æƒé™
2. **æ•°æ®è„±æ•** - æ•æ„Ÿæ•°æ®ä¸å­˜å‚¨ã€ä¸ä¼ è¾“
3. **è¾“å…¥éªŒè¯** - æ‰€æœ‰å¤–éƒ¨è¾“å…¥éƒ½è¦éªŒè¯
4. **é”™è¯¯å¤„ç†** - ä¸æ³„éœ²ç³»ç»Ÿå†…éƒ¨ä¿¡æ¯

---

**è¿™ä¸ªæ¶æ„æ–‡æ¡£åæ˜ äº† Gmail MCP Bridge çš„æ ¸å¿ƒè®¾è®¡ç†å¿µï¼šç®€å•ã€å®ç”¨ã€å¯é ã€‚é€šè¿‡è‰¯å¥½çš„æ•°æ®ç»“æ„è®¾è®¡å’Œç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œç³»ç»Ÿåœ¨ä¿æŒåŠŸèƒ½å®Œæ•´æ€§çš„åŒæ—¶ï¼Œå®ç°äº†é«˜åº¦çš„å¯ç»´æŠ¤æ€§å’Œæ‰©å±•æ€§ã€‚**