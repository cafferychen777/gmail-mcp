#!/usr/bin/env node

/**
 * Gmail MCP Bridge CLI
 * 
 * ç”¨æˆ·å‹å¥½çš„å‘½ä»¤è¡Œç•Œé¢ï¼Œè®©å®‰è£…å˜å¾—åƒ "npm install" ä¸€æ ·ç®€å•
 * 
 * è®¾è®¡å“²å­¦ï¼ˆLinus é£æ ¼ï¼‰:
 * 1. ç®€æ´æ˜äº† - ç”¨æˆ·ä¸éœ€è¦é˜…è¯»é•¿ç¯‡æ–‡æ¡£å°±èƒ½ä½¿ç”¨
 * 2. æ¶ˆé™¤æ­§ä¹‰ - æ¯ä¸ªå‘½ä»¤éƒ½æœ‰æ˜ç¡®çš„ä½œç”¨ï¼Œæ²¡æœ‰æ¨¡ç³Šåœ°å¸¦  
 * 3. å®ç”¨è‡³ä¸Š - è§£å†³ç”¨æˆ·çš„çœŸå®é—®é¢˜ï¼Œä¸æ˜¯ç‚«æŠ€
 */

import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import { InstallationManager } from '../tools/installer/installer.js';
import { SystemDetector } from '../tools/installer/system-detector.js';
import { UserInterface } from '../tools/installer/ui.js';
import { ClaudeConfigManager } from '../tools/installer/claude-config.js';
import { ExtensionManager } from '../tools/installer/extension-manager.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ROOT_DIR = resolve(__dirname, '..');

/**
 * å‘½ä»¤è¡Œç•Œé¢ç±»
 * ç®€å•æœ‰æ•ˆï¼Œæ²¡æœ‰è¿‡åº¦å·¥ç¨‹åŒ–
 */
class GmailMcpCli {
    constructor() {
        this.ui = new UserInterface();
        this.installer = new InstallationManager();
        this.detector = new SystemDetector();
        this.claudeConfig = new ClaudeConfigManager();
        this.extensionManager = new ExtensionManager();
        
        // å‘½ä»¤æ˜ å°„ - ç”¨æ•°æ®è€Œéæ¡ä»¶åˆ†æ”¯
        this.COMMANDS = {
            'install': {
                handler: this.install.bind(this),
                description: 'è‡ªåŠ¨å®‰è£…å’Œé…ç½®æ‰€æœ‰ç»„ä»¶',
                usage: 'gmail-mcp install [--force]'
            },
            'status': {
                handler: this.status.bind(this),
                description: 'æ£€æŸ¥å½“å‰å®‰è£…çŠ¶æ€',
                usage: 'gmail-mcp status'
            },
            'doctor': {
                handler: this.doctor.bind(this),
                description: 'è¯Šæ–­ç³»ç»Ÿé—®é¢˜',
                usage: 'gmail-mcp doctor'
            },
            'fix': {
                handler: this.fix.bind(this),
                description: 'å°è¯•è‡ªåŠ¨ä¿®å¤é—®é¢˜',
                usage: 'gmail-mcp fix'
            },
            'test': {
                handler: this.test.bind(this),
                description: 'æµ‹è¯•åŠŸèƒ½æ˜¯å¦æ­£å¸¸',
                usage: 'gmail-mcp test'
            },
            'uninstall': {
                handler: this.uninstall.bind(this),
                description: 'å®Œå…¨å¸è½½',
                usage: 'gmail-mcp uninstall [--force]'
            },
            'help': {
                handler: this.help.bind(this),
                description: 'æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯',
                usage: 'gmail-mcp help [command]'
            }
        };
    }

    /**
     * ä¸»å…¥å£ç‚¹
     */
    async run() {
        const args = process.argv.slice(2);
        const command = args[0] || 'help';
        const flags = this._parseFlags(args);

        try {
            const commandConfig = this.COMMANDS[command];
            if (commandConfig) {
                await commandConfig.handler(flags);
            } else {
                this.ui.showError(`æœªçŸ¥å‘½ä»¤: ${command}`);
                await this.help();
                process.exit(1);
            }
        } catch (error) {
            this.ui.showError(`æ‰§è¡Œå¤±è´¥: ${error.message}`);
            
            if (flags.verbose) {
                console.error('\nè¯¦ç»†é”™è¯¯ä¿¡æ¯:');
                console.error(error.stack);
            }
            
            process.exit(1);
        } finally {
            this.ui.close();
        }
    }

    /**
     * å®‰è£…å‘½ä»¤
     */
    async install(flags) {
        if (flags.dryRun) {
            this.ui.showInfo('ğŸ§ª æ¨¡æ‹Ÿè¿è¡Œæ¨¡å¼ - ä»…æ˜¾ç¤ºå°†è¦æ‰§è¡Œçš„æ“ä½œ');
            await this._showInstallPlan();
            return;
        }

        if (!flags.force) {
            const confirmed = await this.ui.confirm('ç¡®å®šè¦å¼€å§‹å®‰è£…å—ï¼Ÿè¿™å°†ä¿®æ”¹æ‚¨çš„ç³»ç»Ÿé…ç½®ã€‚');
            if (!confirmed) {
                this.ui.showInfo('å®‰è£…å·²å–æ¶ˆ');
                return;
            }
        }

        await this.installer.install({ 
            force: flags.force, 
            verbose: flags.verbose,
            autoFix: true // å¯ç”¨æ™ºèƒ½è‡ªåŠ¨ä¿®å¤
        });
    }

    /**
     * çŠ¶æ€æ£€æŸ¥å‘½ä»¤
     */
    async status(flags) {
        this.ui.showInfo('ğŸ” æ£€æŸ¥ Gmail MCP Bridge çŠ¶æ€...');
        
        const spinner = this.ui.showSpinner('æ£€æŸ¥ç³»ç»ŸçŠ¶æ€...');
        
        try {
            // å¹¶è¡Œæ£€æŸ¥æ‰€æœ‰ç»„ä»¶çŠ¶æ€
            const [systemStatus, claudeStatus, extensionStatus] = await Promise.all([
                this.detector.quickDiagnosis(),
                this.claudeConfig.getStatus(),
                this.extensionManager.getStatus()
            ]);
            
            spinner.stop();
            
            // æ˜¾ç¤ºæ•´ä½“çŠ¶æ€
            this._showStatusSummary({
                system: systemStatus,
                claude: claudeStatus,
                extension: extensionStatus
            });

        } catch (error) {
            spinner.stop();
            throw error;
        }
    }

    /**
     * ç³»ç»Ÿè¯Šæ–­å‘½ä»¤
     */
    async doctor(flags) {
        this.ui.showInfo('ğŸ©º è¿è¡Œç³»ç»Ÿè¯Šæ–­...');
        
        const diagnosis = await this.detector.quickDiagnosis();
        this.ui.showDiagnosisResult(diagnosis);
        
        if (diagnosis.overall !== 'ready') {
            const shouldFix = await this.ui.confirm('å‘ç°é—®é¢˜ï¼Œæ˜¯å¦å°è¯•è‡ªåŠ¨ä¿®å¤ï¼Ÿ');
            if (shouldFix) {
                await this.fix(flags);
            }
        }
    }

    /**
     * è‡ªåŠ¨ä¿®å¤å‘½ä»¤
     */
    async fix(flags) {
        this.ui.showInfo('ğŸ”§ å°è¯•è‡ªåŠ¨ä¿®å¤...');
        
        const fixes = [];
        
        try {
            // ä¿®å¤ Claude é…ç½®
            const claudeRepair = await this.claudeConfig.repairConfig(
                resolve(ROOT_DIR, 'gmail-mcp-extension')
            );
            if (claudeRepair.fixes.length > 0) {
                fixes.push(...claudeRepair.fixes.map(fix => `Claude: ${fix}`));
            }

            // TODO: æ·»åŠ æ›´å¤šä¿®å¤é€»è¾‘
            
            if (fixes.length > 0) {
                this.ui.showSuccess(`âœ… ä¿®å¤å®Œæˆ:`);
                fixes.forEach(fix => this.ui.showInfo(`  â€¢ ${fix}`));
            } else {
                this.ui.showInfo('æœªå‘ç°éœ€è¦ä¿®å¤çš„é—®é¢˜');
            }
            
        } catch (error) {
            this.ui.showError(`è‡ªåŠ¨ä¿®å¤å¤±è´¥: ${error.message}`);
        }
    }

    /**
     * æµ‹è¯•å‘½ä»¤
     */
    async test(flags) {
        this.ui.showInfo('ğŸ§ª è¿è¡ŒåŠŸèƒ½æµ‹è¯•...');
        
        const tests = [];
        
        // æµ‹è¯•ç³»ç»Ÿè¦æ±‚
        tests.push(await this._testSystemRequirements());
        
        // æµ‹è¯• Claude é…ç½®
        tests.push(await this._testClaudeConfig());
        
        // æµ‹è¯•æ‰©å±•é…ç½®
        tests.push(await this._testExtensionConfig());
        
        // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
        this.ui.showTestResults({
            tests,
            total: tests.length,
            passed: tests.filter(t => t.passed).length,
            failed: tests.filter(t => !t.passed).length,
            overall: tests.every(t => t.passed) ? 'success' : 'failure'
        });
    }

    /**
     * å¸è½½å‘½ä»¤
     */
    async uninstall(flags) {
        if (!flags.force) {
            this.ui.showWarning('âš ï¸  è¿™å°†å®Œå…¨ç§»é™¤ Gmail MCP Bridge çš„æ‰€æœ‰é…ç½®ã€‚');
            const confirmed = await this.ui.confirm('ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
            if (!confirmed) {
                this.ui.showInfo('å¸è½½å·²å–æ¶ˆ');
                return;
            }
        }

        await this.installer.uninstall();
    }

    /**
     * å¸®åŠ©å‘½ä»¤
     */
    async help(flags) {
        if (flags.command && this.COMMANDS[flags.command]) {
            this._showCommandHelp(flags.command);
        } else {
            this.ui.showHelp();
        }
    }

    /**
     * è§£æå‘½ä»¤è¡Œæ ‡å¿—
     */
    _parseFlags(args) {
        const flags = {
            force: false,
            verbose: false,
            dryRun: false,
            help: false
        };

        for (let i = 1; i < args.length; i++) {
            const arg = args[i];
            switch (arg) {
                case '--force':
                case '-f':
                    flags.force = true;
                    break;
                case '--verbose':
                case '-v':
                    flags.verbose = true;
                    break;
                case '--dry-run':
                    flags.dryRun = true;
                    break;
                case '--help':
                case '-h':
                    flags.help = true;
                    break;
                default:
                    if (arg.startsWith('--')) {
                        console.warn(`è­¦å‘Š: æœªçŸ¥é€‰é¡¹ ${arg}`);
                    } else {
                        // éé€‰é¡¹å‚æ•°
                        flags.command = arg;
                    }
            }
        }

        return flags;
    }

    /**
     * æ˜¾ç¤ºå®‰è£…è®¡åˆ’ï¼ˆdry runï¼‰
     */
    async _showInstallPlan() {
        const steps = [
            '1. æ£€æµ‹ç³»ç»Ÿç¯å¢ƒ',
            '2. å¤‡ä»½ç°æœ‰é…ç½®',
            '3. å®‰è£… MCP æœåŠ¡å™¨ä¾èµ–',
            '4. é…ç½® Claude Desktop',
            '5. è®¾ç½®æµè§ˆå™¨æ‰©å±•',
            '6. éªŒè¯å®‰è£…'
        ];

        this.ui.showInfo('ğŸ“‹ å®‰è£…è®¡åˆ’:');
        steps.forEach(step => this.ui.showInfo(`  ${step}`));
    }

    /**
     * æ˜¾ç¤ºçŠ¶æ€æ‘˜è¦
     */
    _showStatusSummary(status) {
        console.log('\nğŸ“Š ç³»ç»ŸçŠ¶æ€æ‘˜è¦');
        console.log('â”€'.repeat(50));
        
        // ç³»ç»ŸçŠ¶æ€
        if (status.system.overall === 'ready') {
            this.ui.showSuccess(`ç³»ç»Ÿç¯å¢ƒ: å°±ç»ª (${status.system.ready}/${status.system.total})`);
        } else {
            this.ui.showError(`ç³»ç»Ÿç¯å¢ƒ: ${status.system.issues} ä¸ªé—®é¢˜`);
        }

        // Claude çŠ¶æ€
        if (status.claude.status === 'configured') {
            this.ui.showSuccess(`Claude Desktop: ${status.claude.message}`);
        } else {
            this.ui.showError(`Claude Desktop: ${status.claude.message}`);
        }

        // æ‰©å±•çŠ¶æ€
        if (status.extension.status === 'configured') {
            this.ui.showSuccess(`Chrome æ‰©å±•: ${status.extension.message}`);
        } else if (status.extension.status === 'partial') {
            this.ui.showWarning(`Chrome æ‰©å±•: ${status.extension.message}`);
        } else {
            this.ui.showError(`Chrome æ‰©å±•: ${status.extension.message}`);
        }
    }

    /**
     * æµ‹è¯•ç³»ç»Ÿè¦æ±‚
     */
    async _testSystemRequirements() {
        try {
            const diagnosis = await this.detector.quickDiagnosis();
            return {
                name: 'ç³»ç»Ÿè¦æ±‚',
                passed: diagnosis.overall === 'ready',
                status: diagnosis.overall === 'ready' ? 'é€šè¿‡' : 'å¤±è´¥',
                details: `${diagnosis.ready}/${diagnosis.total} é¡¹æ£€æŸ¥é€šè¿‡`,
                suggestion: diagnosis.overall !== 'ready' ? 'è¿è¡Œ gmail-mcp doctor æŸ¥çœ‹è¯¦æƒ…' : null
            };
        } catch (error) {
            return {
                name: 'ç³»ç»Ÿè¦æ±‚',
                passed: false,
                status: 'é”™è¯¯',
                details: error.message
            };
        }
    }

    /**
     * æµ‹è¯• Claude é…ç½®
     */
    async _testClaudeConfig() {
        try {
            const verification = await this.claudeConfig.verify();
            return {
                name: 'Claude Desktop é…ç½®',
                passed: verification.valid,
                status: verification.valid ? 'æ­£å¸¸' : 'å¼‚å¸¸',
                details: verification.valid ? verification.serverScript : verification.error,
                suggestion: !verification.valid ? 'è¿è¡Œ gmail-mcp fix å°è¯•ä¿®å¤' : null
            };
        } catch (error) {
            return {
                name: 'Claude Desktop é…ç½®',
                passed: false,
                status: 'é”™è¯¯',
                details: error.message
            };
        }
    }

    /**
     * æµ‹è¯•æ‰©å±•é…ç½®
     */
    async _testExtensionConfig() {
        try {
            const verification = await this.extensionManager.verify();
            return {
                name: 'Chrome æ‰©å±•é…ç½®',
                passed: verification.valid,
                status: verification.valid ? 'æ­£å¸¸' : 'å¼‚å¸¸',
                details: verification.extensionDetected ? 'æ‰©å±•å·²å®‰è£…' : 'Native Host å·²é…ç½®',
                suggestion: !verification.extensionDetected ? 'éœ€è¦æ‰‹åŠ¨å®‰è£… Chrome æ‰©å±•' : null
            };
        } catch (error) {
            return {
                name: 'Chrome æ‰©å±•é…ç½®',
                passed: false,
                status: 'é”™è¯¯',
                details: error.message
            };
        }
    }

    /**
     * æ˜¾ç¤ºå•ä¸ªå‘½ä»¤çš„å¸®åŠ©
     */
    _showCommandHelp(commandName) {
        const command = this.COMMANDS[commandName];
        console.log(`\n${command.usage}`);
        console.log(`${command.description}\n`);
    }
}

// CLI å…¥å£ç‚¹
const cli = new GmailMcpCli();
cli.run().catch(error => {
    console.error('è‡´å‘½é”™è¯¯:', error.message);
    process.exit(1);
});